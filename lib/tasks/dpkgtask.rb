#!/usr/bin/env ruby

# Define a package task library to aid in the definition of GEM
# packages.

require 'rubygems'
require 'rake'
require 'rubygems/user_interaction'
require 'rubygems/builder'

module Rake

  # Create a package based upon a dpkg spec.  
  # In addition to the Rake targets generated by PackageTask, a
  # GemPackageTask will also generate the following tasks:
  #
  # [<b>"<em>package_dir</em>/<em>name</em>-<em>version</em>.gem"</b>]
  #   Create a Ruby GEM package with the given name and version.
  #
  # Example using a Ruby GEM spec:
  #
  #   require 'rubygems'
  #
  #   spec = Gem::Specification.new do |s|
  #     s.platform = Gem::Platform::RUBY
  #     s.summary = "Ruby based make-like utility."
  #     s.name = 'rake'
  #     s.version = PKG_VERSION
  #     s.requirements << 'none'
  #     s.require_path = 'lib'
  #     s.autorequire = 'rake'
  #     s.files = PKG_FILES
  #     s.description = <<EOF
  #   Rake is a Make-like program implemented in Ruby. Tasks
  #   and dependencies are specified in standard Ruby syntax. 
  #   EOF
  #   end
  #   
  #   Rake::GemPackageTask.new(spec) do |pkg|
  #     pkg.need_zip = true
  #     pkg.need_tar = true
  #   end
  #
  class DpkgTask
    # Debian control containing the metadata for this package.  The
    # name and version are automatically determined
    # from the control and don't need to be explicitly provided.
    attr_accessor :control, :package_dir, :package_name, :control_files, :lib_files, :sbin_files, :doc_files, :config_files

    # Create a DPKG task library.  Automatically define the dpkg
    # if a block is given.  If no block is supplied, then +define+
    # needs to be called to define the task.
    def initialize(control)
      init(control)
      yield self if block_given?
      define if block_given?
    end

    # Initialization tasks without the "yield self" or define
    # operations.
    def init(control)
      @package_name = "#{control.Package}-#{control.Version}"
      @package_dir  = 'pkg'
      @control      = control
    end

    # Create the Rake tasks and actions specified by this
    # DpkdTask.  (+define+ is automatically called if a block is
    # given to +new+).
    def define
      task :package => [:dpkg]

      desc "Build the dpkg file #{dpkg_file}"
      task :dpkg => "#{dpkg_file}" 

      file dpkg_file => File.join(package_dir, "debian.deb") do
        cp File.join(package_dir,"debian.deb"), dpkg_file
      end

      file File.join(package_dir, "debian.deb") => [build_tree, debian_dir, :permissions] do
        when_writing("Creating dpkg") {
          sh %{dpkg-deb -b #{build_tree}}
        }
      end

      file "#{build_tree}/DEBIAN" => control_files do |t|
        mkdir_p t.name
        File.open("#{t.name}/control", "w") do |f|
          for key, value in @control.marshal_dump
            f.write "#{key}: #{value}\n"
          end
        end
        File.open("#{t.name}/conffiles", "w") do |f|
          f.write "/etc/init.d/smart-proxy\n/etc/default/smart-proxy\n#{config_files.gsub(/config/,"/etc/smart-proxy").join("\n")}\n"
        end
        link_tree control_files, t.name, "extra/build/"
      end

      file build_tree => ["#{build_tree}/usr/lib/smart-proxy", "#{build_tree}/etc", "#{build_tree}/usr/share/doc/smart-proxy", "#{build_tree}/usr/sbin"]

      task :permissions do
        #sh %{sudo chown -R root:root #{build_tree}}
      end

      file "#{build_tree}/usr/lib/smart-proxy" => lib_files do |t|
        link_tree lib_files, t.name
      end
      file "#{build_tree}/usr/share/doc/smart-proxy" => doc_files do |t|
        link_tree doc_files, t.name
      end
      file "#{build_tree}/usr/sbin" => sbin_files do |t|
        link_tree sbin_files, t.name, "bin/"
      end
      file "#{build_tree}/etc" => "extra/smart-proxy" do |t|
        mkdir_p File.join(build_tree, "etc", "init.d")
        cp "extra/smart-proxy", File.join(build_tree, "etc", "init.d")
        mkdir File.join(build_tree, "etc", "default")
        sh %{/bin/echo ENABLE_SMART_PROXY=yes > #{File.join(build_tree, "etc", "default", "smart-proxy")}}
        link_tree config_files, "#{t.name}/smart-proxy", "config/"
      end
      self
    end

    def link_tree files, where, trim=nil
      mkdir_p where rescue nil
      files.each do |fn|
        dst = trim ? fn.sub(trim, "") : fn
        f = File.join(where, dst)
        fdir = File.dirname(f)
        mkdir_p(fdir) if !File.exist?(fdir)
        if File.directory?(fn)
          mkdir_p(f)
        else
          rm_f f
          safe_ln(fn, f)
        end
      end
    end
    def build_tree
      "#{package_dir}/debian"
    end
    def dpkg_file
      "#{package_dir}/#{package_name}.deb"
    end

    def debian_dir
      "#{build_tree}/DEBIAN"
    end

  end
end
